{
  "version": 3,
  "sources": ["../../../../src/cli/codegen_templates/component_api.ts"],
  "sourcesContent": ["import path from \"path\";\nimport { Context, logError } from \"../../bundler/context.js\";\nimport { entryPoints } from \"../../bundler/index.js\";\nimport {\n  ComponentDirectory,\n  toComponentDefinitionPath,\n} from \"../lib/components/definition/directoryStructure.js\";\nimport { StartPushResponse } from \"../lib/deployApi/startPush.js\";\nimport { importPath, moduleIdentifier } from \"./api.js\";\nimport { header } from \"./common.js\";\nimport {\n  ComponentExports,\n  EvaluatedComponentDefinition,\n} from \"../lib/deployApi/componentDefinition.js\";\nimport { Identifier } from \"../lib/deployApi/types.js\";\nimport { ComponentDefinitionPath } from \"../lib/deployApi/paths.js\";\nimport { resolveFunctionReference } from \"./component_server.js\";\n\nexport function componentApiJs(isRoot: boolean) {\n  const lines = [];\n  if (isRoot) {\n    lines.push(header(\"Generated `api` utility.\"));\n    lines.push(`\n      import { anyApi } from \"convex/server\";\n\n      /**\n       * A utility for referencing Convex functions in your app's API.\n       *\n       * Usage:\n       * \\`\\`\\`js\n       * const myFunctionReference = api.myModule.myFunction;\n       * \\`\\`\\`\n       */\n      export const api = anyApi;\n      export const internal = anyApi;\n    `);\n  } else {\n    lines.push(header(\"Generated `api` utility.\"));\n    lines.push(`\n      import { anyApi } from \"convex/server\";\n      /**\n       * A utility for referencing Convex functions in your app's API.\n       *\n       * Usage:\n       * \\`\\`\\`js\n       * const myFunctionReference = functions.myModule.myFunction;\n       * \\`\\`\\`\n       */\n      export const functions = anyApi;\n    `);\n  }\n  return lines.join(\"\\n\");\n}\n\nexport function rootComponentApiCJS() {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`const { anyApi } = require(\"convex/server\");`);\n  lines.push(`module.exports = {\n    api: anyApi,\n    internal: anyApi,\n  };`);\n  return lines.join(\"\\n\");\n}\n\nexport function componentApiStubDTS(isRoot: boolean) {\n  const lines = [];\n  lines.push(header(\"Generated `api` utility.\"));\n  lines.push(`import type { AnyApi } from \"convex/server\";`);\n  if (isRoot) {\n    lines.push(`\n      export declare const api: AnyApi;\n      export declare const internal: AnyApi;\n    `);\n  } else {\n    lines.push(`export declare const functions: AnyApi;`);\n  }\n  return lines.join(\"\\n\");\n}\n\nexport async function componentApiDTS(\n  ctx: Context,\n  startPush: StartPushResponse,\n  rootComponent: ComponentDirectory,\n  componentDirectory: ComponentDirectory,\n) {\n  const isRoot = componentDirectory.isRoot;\n  const definitionPath = toComponentDefinitionPath(\n    rootComponent,\n    componentDirectory,\n  );\n  const absModulePaths = await entryPoints(ctx, componentDirectory.path, false);\n  const modulePaths = absModulePaths.map((p) =>\n    path.relative(componentDirectory.path, p),\n  );\n\n  const lines = [];\n  if (isRoot) {\n    lines.push(header(\"Generated `api` utility.\"));\n    for (const modulePath of modulePaths) {\n      const ident = moduleIdentifier(modulePath);\n      const path = importPath(modulePath);\n      lines.push(`import type * as ${ident} from \"../${path}.js\";`);\n    }\n    lines.push(`\n      import type {\n        ApiFromModules,\n        FilterApi,\n        FunctionReference,\n      } from \"convex/server\";\n      /**\n       * A utility for referencing Convex functions in your app's API.\n       *\n       * Usage:\n       * \\`\\`\\`js\n       * const myFunctionReference = api.myModule.myFunction;\n       * \\`\\`\\`\n       */\n      declare const fullApi: ApiFromModules<{\n    `);\n    for (const modulePath of modulePaths) {\n      const ident = moduleIdentifier(modulePath);\n      const path = importPath(modulePath);\n      lines.push(`  \"${path}\": typeof ${ident},`);\n    }\n    lines.push(`}>;`);\n    for await (const line of codegenApiWithMounts(\n      ctx,\n      startPush,\n      definitionPath,\n    )) {\n      lines.push(line);\n    }\n    lines.push(`\n      export declare const api: FilterApi<typeof fullApiWithMounts, FunctionReference<any, \"public\">>;\n      export declare const internal: FilterApi<typeof fullApiWithMounts, FunctionReference<any, \"internal\">>;\n    `);\n  } else {\n    lines.push(header(\"Generated `api` utility.\"));\n    for (const modulePath of modulePaths) {\n      const ident = moduleIdentifier(modulePath);\n      const path = importPath(modulePath);\n      lines.push(`import type * as ${ident} from \"../${path}.js\";`);\n    }\n    lines.push(`\n      import type {\n        ApiFromModules,\n        FunctionReference,\n      } from \"convex/server\";\n      /**\n       * A utility for referencing Convex functions in your app's API.\n       *\n       * Usage:\n       * \\`\\`\\`js\n       * const myFunctionReference = functions.myModule.myFunction;\n       * \\`\\`\\`\n       */\n      declare const functions: ApiFromModules<{\n    `);\n    for (const modulePath of modulePaths) {\n      const ident = moduleIdentifier(modulePath);\n      const path = importPath(modulePath);\n      lines.push(`  \"${path}\": typeof ${ident},`);\n    }\n    lines.push(`}>;`);\n  }\n  return lines.join(\"\\n\");\n}\n\nasync function* codegenApiWithMounts(\n  ctx: Context,\n  startPush: StartPushResponse,\n  definitionPath: ComponentDefinitionPath,\n): AsyncGenerator<string> {\n  const mountTree = await buildMountTree(ctx, startPush, definitionPath, []);\n  if (!mountTree) {\n    yield \"declare const fullApiWithMounts: typeof fullApi;\";\n    return;\n  }\n  yield \"declare const fullApiWithMounts: typeof fullApi &\";\n  yield* codegenMountTree(mountTree);\n  yield `;`;\n}\n\nfunction* codegenMountTree(tree: MountTree): Generator<string> {\n  yield `{`;\n  for (const [identifier, subtree] of Object.entries(tree)) {\n    if (typeof subtree === \"string\") {\n      yield `\"${identifier}\": ${subtree},`;\n    } else {\n      yield `\"${identifier}\":`;\n      yield* codegenMountTree(subtree);\n      yield `,`;\n    }\n  }\n  yield `}`;\n}\n\ninterface MountTree {\n  [identifier: string]: MountTree | string;\n}\n\nasync function buildMountTree(\n  ctx: Context,\n  startPush: StartPushResponse,\n  definitionPath: ComponentDefinitionPath,\n  attributes: string[],\n): Promise<MountTree | null> {\n  const analysis = startPush.analysis[definitionPath];\n  if (!analysis) {\n    logError(ctx, `No analysis found for component ${definitionPath}`);\n    return await ctx.crash(1, \"fatal\");\n  }\n  let current = analysis.definition.exports.branch;\n  for (const attribute of attributes) {\n    const componentExport = current.find(\n      ([identifier]) => identifier === attribute,\n    );\n    if (!componentExport) {\n      logError(ctx, `No export found for ${attribute}`);\n      return await ctx.crash(1, \"fatal\");\n    }\n    const [_, node] = componentExport;\n    if (node.type !== \"branch\") {\n      logError(ctx, `Expected branch at ${attribute}`);\n      return await ctx.crash(1, \"fatal\");\n    }\n    current = node.branch;\n  }\n  return buildComponentMountTree(ctx, startPush, analysis, current);\n}\n\nasync function buildComponentMountTree(\n  ctx: Context,\n  startPush: StartPushResponse,\n  analysis: EvaluatedComponentDefinition,\n  exports: Array<[Identifier, ComponentExports]>,\n): Promise<MountTree | null> {\n  const result: MountTree = {};\n  let nonEmpty = false;\n  for (const [identifier, componentExport] of exports) {\n    if (componentExport.type === \"leaf\") {\n      // If we're at a child component reference, follow it and build its export tree.\n      if (componentExport.leaf.startsWith(\"_reference/childComponent/\")) {\n        const suffix = componentExport.leaf.slice(\n          \"_reference/childComponent/\".length,\n        );\n        const [componentName, ...attributes] = suffix.split(\"/\");\n        const childComponent = analysis.definition.childComponents.find(\n          (c) => c.name === componentName,\n        );\n        if (!childComponent) {\n          logError(ctx, `No child component found for ${componentName}`);\n          return await ctx.crash(1, \"fatal\");\n        }\n        const childTree = await buildMountTree(\n          ctx,\n          startPush,\n          childComponent.path,\n          attributes,\n        );\n        if (childTree) {\n          result[identifier] = childTree;\n          nonEmpty = true;\n        }\n      }\n      // If we're at a function reference outside the root, codegen it as a leaf.\n      const isRoot = analysis.definition.definitionType.type === \"app\";\n      if (!isRoot && componentExport.leaf.startsWith(\"_reference/function/\")) {\n        const leaf = await resolveFunctionReference(\n          ctx,\n          analysis,\n          componentExport.leaf,\n          \"public\",\n        );\n        result[identifier] = leaf;\n        nonEmpty = true;\n      }\n    } else {\n      const subTree = await buildComponentMountTree(\n        ctx,\n        startPush,\n        analysis,\n        componentExport.branch,\n      );\n      if (subTree) {\n        result[identifier] = subTree;\n        nonEmpty = true;\n      }\n    }\n  }\n  return nonEmpty ? result : null;\n}\n"],
  "mappings": "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",
  "names": ["path"]
}

{
  "version": 3,
  "sources": ["../../../../../../src/cli/lib/components/definition/directoryStructure.ts"],
  "sourcesContent": ["import path from \"path\";\nimport { Context, logError } from \"../../../../bundler/context.js\";\nimport { DEFINITION_FILENAME, ROOT_DEFINITION_FILENAME } from \"../constants.js\";\n\n/**\n * A component definition's location on the local filesystem,\n * using absolute paths.\n *\n * For module resolution it may be useful to avoid resolving any symlinks:\n * node modules are often symlinked by e.g. pnpm but relative paths should generally be\n * understood from their symlink location.\n *\n * None of these properties are the import string, which might have been an unqualifed import\n * (e.g. 'convex-waitlist' instead of '../node_modules/convex-waitlist/component.config.ts')\n */\nexport type ComponentDirectory = {\n  isRoot: boolean;\n  path: string;\n  definitionPath: string;\n};\n\n/**\n * Qualify (ensure a leading dot) a path and make it relative to a working dir.\n * Qualifying a path clarifies to esbuild that it represents a local file system\n * path, not a remote path on the npm registry.\n *\n * Because the path is made relative without resolving symlinks this is a reasonable\n * identifier for the component directory (given a consistent working directory).\n */\nexport function qualifiedDefinitionPath(\n  directory: ComponentDirectory,\n  workingDir = \".\",\n) {\n  const definitionPath = path.relative(workingDir, directory.definitionPath);\n  return `./${definitionPath}`;\n}\n\n// NB: The process cwd will be used to resolve the directory specified in the constructor.\nexport function isComponentDirectory(\n  ctx: Context,\n  directory: string,\n  isRoot: boolean,\n):\n  | { kind: \"ok\"; component: ComponentDirectory }\n  | { kind: \"err\"; why: string } {\n  if (!ctx.fs.exists(directory)) {\n    return { kind: \"err\", why: `Directory doesn't exist` };\n  }\n  const dirStat = ctx.fs.stat(directory);\n  if (!dirStat.isDirectory()) {\n    return { kind: \"err\", why: `Not a directory` };\n  }\n\n  // Check that we have a definition file.\n  const filename = isRoot ? ROOT_DEFINITION_FILENAME : DEFINITION_FILENAME;\n  const definitionPath = path.resolve(path.join(directory, filename));\n  if (!ctx.fs.exists(definitionPath)) {\n    return {\n      kind: \"err\",\n      why: `Directory doesn't contain a ${filename} file`,\n    };\n  }\n  const definitionStat = ctx.fs.stat(definitionPath);\n  if (!definitionStat.isFile()) {\n    return {\n      kind: \"err\",\n      why: `Component definition ${filename} isn't a file`,\n    };\n  }\n  return {\n    kind: \"ok\",\n    component: {\n      isRoot,\n      path: path.resolve(directory),\n      definitionPath: definitionPath,\n    },\n  };\n}\n\nexport async function buildComponentDirectory(\n  ctx: Context,\n  definitionPath: string,\n): Promise<ComponentDirectory> {\n  const isRoot = path.basename(definitionPath) === ROOT_DEFINITION_FILENAME;\n  const isComponent = isComponentDirectory(\n    ctx,\n    path.dirname(definitionPath),\n    isRoot,\n  );\n  if (isComponent.kind === \"err\") {\n    logError(\n      ctx,\n      `Invalid component directory (${isComponent.why}): ${path.dirname(definitionPath)}`,\n    );\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  return isComponent.component;\n}\n\n/**\n * ComponentPath is the type of path sent to the server to identify a\n * component definition. It is the unqualified (it never starts with \"./\")\n * relative path from the convex directory of the app (root component)\n * to the directory where a component definition lives.\n *\n * Note the convex/ directory of the root component is not necessarily\n * the working directory. It is currently never the same as the working\n * directory since `npx convex` must be invoked from the package root instead.\n */\nexport type ComponentDefinitionPath = string & {\n  __brand: \"ComponentDefinitionPath\";\n};\n\nexport function toComponentDefinitionPath(\n  rootComponent: ComponentDirectory,\n  component: ComponentDirectory,\n): ComponentDefinitionPath {\n  return path.relative(\n    rootComponent.path,\n    component.path,\n  ) as ComponentDefinitionPath;\n}\n\nexport function toAbsolutePath(\n  rootComponent: ComponentDirectory,\n  componentDefinitionPath: ComponentDefinitionPath,\n) {\n  return path.normalize(path.join(rootComponent.path, componentDefinitionPath));\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAiB;AACjB,qBAAkC;AAClC,uBAA8D;AA2BvD,SAAS,wBACd,WACA,aAAa,KACb;AACA,QAAM,iBAAiB,YAAAA,QAAK,SAAS,YAAY,UAAU,cAAc;AACzE,SAAO,KAAK;AACd;AAGO,SAAS,qBACd,KACA,WACA,QAG+B;AAC/B,MAAI,CAAC,IAAI,GAAG,OAAO,SAAS,GAAG;AAC7B,WAAO,EAAE,MAAM,OAAO,KAAK,0BAA0B;AAAA,EACvD;AACA,QAAM,UAAU,IAAI,GAAG,KAAK,SAAS;AACrC,MAAI,CAAC,QAAQ,YAAY,GAAG;AAC1B,WAAO,EAAE,MAAM,OAAO,KAAK,kBAAkB;AAAA,EAC/C;AAGA,QAAM,WAAW,SAAS,4CAA2B;AACrD,QAAM,iBAAiB,YAAAA,QAAK,QAAQ,YAAAA,QAAK,KAAK,WAAW,QAAQ,CAAC;AAClE,MAAI,CAAC,IAAI,GAAG,OAAO,cAAc,GAAG;AAClC,WAAO;AAAA,MACL,MAAM;AAAA,MACN,KAAK,+BAA+B;AAAA,IACtC;AAAA,EACF;AACA,QAAM,iBAAiB,IAAI,GAAG,KAAK,cAAc;AACjD,MAAI,CAAC,eAAe,OAAO,GAAG;AAC5B,WAAO;AAAA,MACL,MAAM;AAAA,MACN,KAAK,wBAAwB;AAAA,IAC/B;AAAA,EACF;AACA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,WAAW;AAAA,MACT;AAAA,MACA,MAAM,YAAAA,QAAK,QAAQ,SAAS;AAAA,MAC5B;AAAA,IACF;AAAA,EACF;AACF;AAEA,eAAsB,wBACpB,KACA,gBAC6B;AAC7B,QAAM,SAAS,YAAAA,QAAK,SAAS,cAAc,MAAM;AACjD,QAAM,cAAc;AAAA,IAClB;AAAA,IACA,YAAAA,QAAK,QAAQ,cAAc;AAAA,IAC3B;AAAA,EACF;AACA,MAAI,YAAY,SAAS,OAAO;AAC9B;AAAA,MACE;AAAA,MACA,gCAAgC,YAAY,SAAS,YAAAA,QAAK,QAAQ,cAAc;AAAA,IAClF;AACA,WAAO,MAAM,IAAI,MAAM,GAAG,yBAAyB;AAAA,EACrD;AACA,SAAO,YAAY;AACrB;AAgBO,SAAS,0BACd,eACA,WACyB;AACzB,SAAO,YAAAA,QAAK;AAAA,IACV,cAAc;AAAA,IACd,UAAU;AAAA,EACZ;AACF;AAEO,SAAS,eACd,eACA,yBACA;AACA,SAAO,YAAAA,QAAK,UAAU,YAAAA,QAAK,KAAK,cAAc,MAAM,uBAAuB,CAAC;AAC9E;",
  "names": ["path"]
}

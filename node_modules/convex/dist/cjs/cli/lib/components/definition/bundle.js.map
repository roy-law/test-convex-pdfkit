{
  "version": 3,
  "sources": ["../../../../../../src/cli/lib/components/definition/bundle.ts"],
  "sourcesContent": ["import path from \"path\";\nimport {\n  ComponentDirectory,\n  ComponentDefinitionPath,\n  buildComponentDirectory,\n  isComponentDirectory,\n  qualifiedDefinitionPath,\n  toComponentDefinitionPath,\n} from \"./directoryStructure.js\";\nimport {\n  Context,\n  logError,\n  logMessage,\n  logWarning,\n  showSpinner,\n} from \"../../../../bundler/context.js\";\nimport esbuild, { BuildOptions, Metafile, OutputFile, Plugin } from \"esbuild\";\nimport chalk from \"chalk\";\nimport { createRequire } from \"module\";\nimport {\n  AppDefinitionSpecWithoutImpls,\n  ComponentDefinitionSpecWithoutImpls,\n} from \"../../config.js\";\nimport {\n  Bundle,\n  bundle,\n  bundleAuthConfig,\n  bundleSchema,\n  entryPointsByEnvironment,\n} from \"../../../../bundler/index.js\";\nimport { NodeDependency } from \"../../deployApi/modules.js\";\n\n/**\n * An esbuild plugin to mark component definitions external or return a list of\n * all component definitions.\n *\n * By default this plugin runs in \"bundle\" mode and marks all imported component\n * definition files as external, not traversing further.\n *\n * If \"discover\" mode is specified it traverses the entire tree.\n */\nfunction componentPlugin({\n  mode = \"bundle\",\n  rootComponentDirectory,\n  verbose,\n  ctx,\n}: {\n  mode: \"discover\" | \"bundle\";\n  rootComponentDirectory: ComponentDirectory;\n  verbose?: boolean;\n  ctx: Context;\n}): Plugin {\n  const components = new Map<string, ComponentDirectory>();\n  return {\n    name: `convex-${mode === \"discover\" ? \"discover-components\" : \"bundle-components\"}`,\n    async setup(build) {\n      // This regex can't be really precise since developers could import\n      // \"component.config\", \"component.config.js\", \"component.config.ts\", etc.\n      build.onResolve({ filter: /.*component.config.*/ }, async (args) => {\n        verbose && logMessage(ctx, \"esbuild resolving import:\", args);\n        if (args.namespace !== \"file\") {\n          verbose && logMessage(ctx, \"  Not a file.\");\n          return;\n        }\n        if (args.kind === \"entry-point\") {\n          verbose && logMessage(ctx, \"  -> Top-level entry-point.\");\n          const componentDirectory = await buildComponentDirectory(\n            ctx,\n            path.resolve(args.path),\n          );\n\n          // No attempt to resolve args.path is made for entry points so they\n          // must be relative or absolute file paths, not npm packages.\n          // Whether we're bundling or discovering, we're done.\n          if (components.get(args.path)) {\n            // We always invoke esbuild in a try/catch.\n            // eslint-disable-next-line no-restricted-syntax\n            throw new Error(\n              `Entry point component \"${args.path}\" already registered.`,\n            );\n          }\n          components.set(args.path, componentDirectory);\n          return;\n        }\n\n        const candidates = [args.path];\n        const ext = path.extname(args.path);\n        if (ext === \".js\") {\n          candidates.push(args.path.slice(0, -\".js\".length) + \".ts\");\n        }\n        if (ext !== \".js\" && ext !== \".ts\") {\n          candidates.push(args.path + \".js\");\n          candidates.push(args.path + \".ts\");\n        }\n        let resolvedPath = undefined;\n        for (const candidate of candidates) {\n          try {\n            // --experimental-import-meta-resolve is required for\n            // `import.meta.resolve` so we'll use `require.resolve`\n            // until then. Hopefully they aren't too different.\n            const require = createRequire(args.resolveDir);\n            resolvedPath = require.resolve(candidate, {\n              paths: [args.resolveDir],\n            });\n            break;\n          } catch (e: any) {\n            if (e.code === \"MODULE_NOT_FOUND\") {\n              continue;\n            }\n            // We always invoke esbuild in a try/catch.\n            // eslint-disable-next-line no-restricted-syntax\n            throw e;\n          }\n        }\n        if (resolvedPath === undefined) {\n          verbose && logMessage(ctx, `  -> ${args.path} not found.`);\n          return;\n        }\n\n        const parentDir = path.dirname(resolvedPath);\n        let imported = components.get(resolvedPath);\n        if (!imported) {\n          const isComponent = isComponentDirectory(ctx, parentDir, false);\n          if (isComponent.kind !== \"ok\") {\n            verbose && logMessage(ctx, \"  -> Not a component:\", isComponent);\n            return;\n          }\n          imported = isComponent.component;\n          components.set(resolvedPath, imported);\n        }\n\n        verbose &&\n          logMessage(ctx, \"  -> Component import! Recording it.\", args.path);\n\n        if (mode === \"discover\") {\n          return {\n            path: resolvedPath,\n          };\n        } else {\n          // In bundle mode, transform external imports to use componentPaths:\n          // import rateLimiter from \"convex_ratelimiter\";\n          // => import rateLimiter from `_componentDeps/${base64('../node_modules/convex_ratelimiter')}`;\n\n          // A componentPath is path from the root component to the directory\n          // of the this component's definition file.\n          const componentPath = toComponentDefinitionPath(\n            rootComponentDirectory,\n            imported,\n          );\n          const encodedPath = hackyMapping(componentPath);\n          return {\n            path: encodedPath,\n            external: true,\n          };\n        }\n      });\n    },\n  };\n}\n\n/** The path on the deployment that identifier a component definition. */\nfunction hackyMapping(componentPath: ComponentDefinitionPath): string {\n  return `./_componentDeps/${Buffer.from(componentPath).toString(\"base64\").replace(/=+$/, \"\")}`;\n}\n\n// Share configuration between the component definition discovery and bundling passes.\nconst SHARED_ESBUILD_OPTIONS = {\n  bundle: true,\n  platform: \"browser\",\n  format: \"esm\",\n  target: \"esnext\",\n\n  // false is the default for splitting.\n  // It's simpler to evaluate these on the server when we don't need a whole\n  // filesystem. Enabled this for speed once the server supports it.\n  splitting: false,\n\n  // place output files in memory at their source locations\n  write: false,\n  outdir: path.parse(process.cwd()).root,\n  outbase: path.parse(process.cwd()).root,\n\n  minify: true,\n  keepNames: true,\n\n  metafile: true,\n} as const satisfies BuildOptions;\n\n// Use the esbuild metafile to discover the dependency graph in which component\n// definitions are nodes.\nexport async function componentGraph(\n  ctx: Context,\n  absWorkingDir: string,\n  rootComponentDirectory: ComponentDirectory,\n  verbose: boolean = true,\n): Promise<{\n  components: Map<string, ComponentDirectory>;\n  dependencyGraph: [ComponentDirectory, ComponentDirectory][];\n}> {\n  let result;\n  try {\n    result = await esbuild.build({\n      absWorkingDir, // This is mostly useful for formatting error messages.\n      entryPoints: [qualifiedDefinitionPath(rootComponentDirectory)],\n      plugins: [\n        componentPlugin({\n          ctx,\n          mode: \"discover\",\n          verbose,\n          rootComponentDirectory,\n        }),\n      ],\n      sourcemap: \"external\",\n      sourcesContent: false,\n\n      ...SHARED_ESBUILD_OPTIONS,\n    });\n    await registerEsbuildReads(ctx, absWorkingDir, result.metafile);\n  } catch (err: any) {\n    logError(ctx, `esbuild failed: ${err}`);\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n\n  if (result.errors.length) {\n    for (const error of result.errors) {\n      console.log(chalk.red(`esbuild error: ${error.text}`));\n    }\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  for (const warning of result.warnings) {\n    console.log(chalk.yellow(`esbuild warning: ${warning.text}`));\n  }\n  return await findComponentDependencies(ctx, result.metafile);\n}\n\n/**\n * Get dependencies of a ComponenDirectory as ComponentPaths.\n *\n * Component paths are paths relative to the root component.\n */\nexport function getDeps(\n  rootComponent: ComponentDirectory,\n  dependencyGraph: [ComponentDirectory, ComponentDirectory][],\n  definitionPath: string,\n): ComponentDefinitionPath[] {\n  return dependencyGraph\n    .filter(\n      ([importer, _imported]) => importer.definitionPath === definitionPath,\n    )\n    .map(([_importer, imported]) =>\n      toComponentDefinitionPath(rootComponent, imported),\n    );\n}\n\n/**\n * The returned dependency graph is an array of tuples of [importer, imported]\n *\n * This doesn't work on just any esbuild metafile because it assumes input\n * imports have not been transformed. We run it on the metafile produced by\n * the esbuild invocation that uses the component plugin in \"discover\" mode.\n */\nasync function findComponentDependencies(\n  ctx: Context,\n  metafile: Metafile,\n): Promise<{\n  components: Map<string, ComponentDirectory>;\n  dependencyGraph: [ComponentDirectory, ComponentDirectory][];\n}> {\n  const { inputs } = metafile;\n  // This filter means we only supports *direct imports* of component definitions\n  // from other component definitions.\n  const componentInputs = Object.keys(inputs).filter((path) =>\n    path.includes(\".config.\"),\n  );\n\n  // Absolute path doesn't appear to be necessary here since only inputs marked\n  // external get transformed to an absolute path but it's not clear what's an\n  // esbuild implementation detail in the metafile or which settings change this.\n  const componentsByAbsPath = new Map<string, ComponentDirectory>();\n  for (const inputPath of componentInputs) {\n    const importer = await buildComponentDirectory(ctx, inputPath);\n    componentsByAbsPath.set(path.resolve(inputPath), importer);\n  }\n  const dependencyGraph: [ComponentDirectory, ComponentDirectory][] = [];\n  for (const inputPath of componentInputs) {\n    const importer = componentsByAbsPath.get(path.resolve(inputPath))!;\n    const { imports } = inputs[inputPath];\n    const componentImports = imports.filter((imp) =>\n      imp.path.includes(\".config.\"),\n    );\n    for (const importPath of componentImports.map((dep) => dep.path)) {\n      const imported = componentsByAbsPath.get(path.resolve(importPath));\n      if (!imported) {\n        logError(\n          ctx,\n          `Didn't find ${path.resolve(importPath)} in ${[...componentsByAbsPath.keys()].toString()}`,\n        );\n        return await ctx.crash(1, \"fatal\");\n      }\n      dependencyGraph.push([importer, imported]);\n    }\n  }\n\n  const components = new Map<string, ComponentDirectory>();\n  for (const directory of componentsByAbsPath.values()) {\n    components.set(directory.path, directory);\n  }\n  return { components, dependencyGraph };\n}\n\n// NB: If a directory linked to is not a member of the passed\n// componentDirectories array then there will be external links\n// with no corresponding definition bundle.\n// That could be made to throw an error but maybe those are already available\n// on the Convex definition filesystem somehow, e.g. builtin components.\n/** Bundle the component definitions listed. */\nexport async function bundleDefinitions(\n  ctx: Context,\n  absWorkingDir: string,\n  dependencyGraph: [ComponentDirectory, ComponentDirectory][],\n  rootComponentDirectory: ComponentDirectory,\n  componentDirectories: ComponentDirectory[],\n  verbose: boolean = false,\n): Promise<{\n  appDefinitionSpecWithoutImpls: AppDefinitionSpecWithoutImpls;\n  componentDefinitionSpecsWithoutImpls: ComponentDefinitionSpecWithoutImpls[];\n}> {\n  let result;\n  try {\n    result = await esbuild.build({\n      absWorkingDir,\n      entryPoints: componentDirectories.map((dir) =>\n        qualifiedDefinitionPath(dir),\n      ),\n      plugins: [\n        componentPlugin({\n          ctx,\n          mode: \"bundle\",\n          verbose,\n          rootComponentDirectory,\n        }),\n      ],\n      sourcemap: false, // we're just building a deps map\n      ...SHARED_ESBUILD_OPTIONS,\n    });\n    await registerEsbuildReads(ctx, absWorkingDir, result.metafile);\n  } catch (err: any) {\n    logError(ctx, `esbuild failed: ${err}`);\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  if (result.errors.length) {\n    for (const error of result.errors) {\n      console.log(chalk.red(`esbuild error: ${error.text}`));\n    }\n    return await ctx.crash(1, \"invalid filesystem data\");\n  }\n  for (const warning of result.warnings) {\n    console.log(chalk.yellow(`esbuild warning: ${warning.text}`));\n  }\n\n  const outputs: {\n    outputJs: OutputFile;\n    outputJsMap?: OutputFile;\n    directory: ComponentDirectory;\n  }[] = [];\n  for (const directory of componentDirectories) {\n    const absInput = path.resolve(absWorkingDir, directory.definitionPath);\n    const expectedOutputJs =\n      absInput.slice(0, absInput.lastIndexOf(\".\")) + \".js\";\n    const expectedOutputMap =\n      absInput.slice(0, absInput.lastIndexOf(\".\")) + \".js.map\";\n    const outputJs = result.outputFiles.filter(\n      (outputFile) => outputFile.path === expectedOutputJs,\n    )[0];\n    if (!outputJs) {\n      logError(\n        ctx,\n        `no JS found matching ${expectedOutputJs} in ${result.outputFiles.map((x) => x.path).toString()}`,\n      );\n      return await ctx.crash(1, \"fatal\");\n    }\n    const outputJsMap = result.outputFiles.filter(\n      (outputFile) => outputFile.path === expectedOutputMap,\n    )[0];\n    outputs.push({\n      outputJs,\n      outputJsMap,\n      directory,\n    });\n  }\n\n  const appBundles = outputs.filter(\n    (out) => out.directory.path === rootComponentDirectory.path,\n  );\n  if (appBundles.length !== 1) {\n    logError(ctx, \"found wrong number of app bundles\");\n    return await ctx.crash(1, \"fatal\");\n  }\n  const appBundle = appBundles[0];\n  const componentBundles = outputs.filter(\n    (out) => out.directory.path !== rootComponentDirectory.path,\n  );\n\n  const componentDefinitionSpecsWithoutImpls = componentBundles.map(\n    ({ directory, outputJs, outputJsMap }) => ({\n      definitionPath: directory.path,\n      definition: {\n        path: path.relative(directory.path, outputJs.path),\n        source: outputJs.text,\n        sourceMap: outputJsMap?.text,\n        environment: \"isolate\" as const,\n      },\n      dependencies: getDeps(\n        rootComponentDirectory,\n        dependencyGraph,\n        directory.definitionPath,\n      ),\n    }),\n  );\n  const appDeps = getDeps(\n    rootComponentDirectory,\n    dependencyGraph,\n    appBundle.directory.definitionPath,\n  );\n  const appDefinitionSpecWithoutImpls = {\n    definition: {\n      path: path.relative(rootComponentDirectory.path, appBundle.outputJs.path),\n      source: appBundle.outputJs.text,\n      sourceMap: appBundle.outputJsMap?.text,\n      environment: \"isolate\" as const,\n    },\n    dependencies: appDeps,\n  };\n  return {\n    appDefinitionSpecWithoutImpls,\n    componentDefinitionSpecsWithoutImpls,\n  };\n}\n\nexport async function bundleImplementations(\n  ctx: Context,\n  rootComponentDirectory: ComponentDirectory,\n  componentDirectories: ComponentDirectory[],\n  nodeExternalPackages: string[],\n  verbose: boolean = false,\n): Promise<{\n  appImplementation: {\n    schema: Bundle | null;\n    functions: Bundle[];\n    externalNodeDependencies: NodeDependency[];\n  };\n  componentImplementations: {\n    schema: Bundle | null;\n    functions: Bundle[];\n    definitionPath: ComponentDefinitionPath;\n  }[];\n}> {\n  let appImplementation;\n  const componentImplementations = [];\n\n  let isRoot = true;\n  for (const directory of [rootComponentDirectory, ...componentDirectories]) {\n    const resolvedPath = path.resolve(\n      rootComponentDirectory.path,\n      directory.path,\n    );\n    let schema;\n    if (!ctx.fs.exists(path.resolve(resolvedPath, \"schema.ts\"))) {\n      schema = null;\n    } else {\n      schema = (await bundleSchema(ctx, resolvedPath))[0] || null;\n    }\n\n    const entryPoints = await entryPointsByEnvironment(\n      ctx,\n      resolvedPath,\n      verbose,\n    );\n    const convexResult: {\n      modules: Bundle[];\n      externalDependencies: Map<string, string>;\n      bundledModuleNames: Set<string>;\n    } = await bundle(ctx, resolvedPath, entryPoints.isolate, true, \"browser\");\n\n    if (convexResult.externalDependencies.size !== 0) {\n      logError(ctx, \"external dependencies not supported\");\n      return await ctx.crash(1, \"fatal\");\n    }\n    const functions = convexResult.modules;\n    if (isRoot) {\n      if (verbose) {\n        showSpinner(ctx, \"Bundling modules for Node.js runtime...\");\n      }\n      const nodeResult: {\n        modules: Bundle[];\n        externalDependencies: Map<string, string>;\n        bundledModuleNames: Set<string>;\n      } = await bundle(\n        ctx,\n        resolvedPath,\n        entryPoints.node,\n        true,\n        \"node\",\n        path.join(\"_deps\", \"node\"),\n        nodeExternalPackages,\n      );\n\n      const externalNodeDependencies: NodeDependency[] = [];\n      for (const [\n        moduleName,\n        moduleVersion,\n      ] of nodeResult.externalDependencies) {\n        externalNodeDependencies.push({\n          name: moduleName,\n          version: moduleVersion,\n        });\n      }\n      const authBundle = await bundleAuthConfig(ctx, resolvedPath);\n      appImplementation = {\n        schema,\n        functions: functions.concat(nodeResult.modules).concat(authBundle),\n        externalNodeDependencies,\n      };\n    } else {\n      componentImplementations.push({\n        // these needs to be a componentPath when sent to the server\n        definitionPath: toComponentDefinitionPath(\n          rootComponentDirectory,\n          directory,\n        ),\n        schema,\n        functions,\n      });\n    }\n    isRoot = false;\n  }\n\n  if (!appImplementation) {\n    logError(ctx, \"No app implementation found\");\n    return await ctx.crash(1, \"fatal\");\n  }\n\n  return { appImplementation, componentImplementations };\n}\n\nasync function registerEsbuildReads(\n  ctx: Context,\n  absWorkingDir: string,\n  metafile: Metafile,\n) {\n  for (const [relPath, input] of Object.entries(metafile.inputs)) {\n    if (\n      // We rewrite these files so this integrity check isn't useful.\n      path.basename(relPath).includes(\"app.config\") ||\n      path.basename(relPath).includes(\"component.config\") ||\n      // TODO: esbuild outputs paths prefixed with \"(disabled)\" when bundling our internal\n      // udf-system package. The files do actually exist locally, though.\n      relPath.indexOf(\"(disabled):\") !== -1 ||\n      relPath.startsWith(\"wasm-binary:\") ||\n      relPath.startsWith(\"wasm-stub:\")\n    ) {\n      continue;\n    }\n    const absPath = path.resolve(absWorkingDir, relPath);\n    const st = ctx.fs.stat(absPath);\n    if (st.size !== input.bytes) {\n      logWarning(\n        ctx,\n        `Bundled file ${absPath} changed right after esbuild invocation`,\n      );\n      // Consider this a transient error so we'll try again and hopefully\n      // no files change right after esbuild next time.\n      return await ctx.crash(1, \"transient\");\n    }\n    ctx.fs.registerPath(absPath, st);\n  }\n}\n"],
  "mappings": "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",
  "names": ["path", "require", "esbuild", "chalk"]
}

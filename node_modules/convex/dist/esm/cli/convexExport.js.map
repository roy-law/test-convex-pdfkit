{
  "version": 3,
  "sources": ["../../../src/cli/convexExport.ts"],
  "sourcesContent": ["import { Command, Option } from \"@commander-js/extra-typings\";\nimport chalk from \"chalk\";\nimport {\n  ensureHasConvexDependency,\n  waitUntilCalled,\n  deploymentFetch,\n  logAndHandleFetchError,\n} from \"./lib/utils.js\";\nimport {\n  logFailure,\n  oneoffContext,\n  Context,\n  showSpinner,\n  logFinishedStep,\n  logError,\n  stopSpinner,\n  changeSpinner,\n} from \"../bundler/context.js\";\nimport {\n  fetchDeploymentCredentialsProvisionProd,\n  deploymentSelectionFromOptions,\n} from \"./lib/api.js\";\nimport { subscribe } from \"./lib/run.js\";\nimport { nodeFs } from \"../bundler/fs.js\";\nimport path from \"path\";\nimport { deploymentDashboardUrlPage } from \"./dashboard.js\";\nimport { actionDescription } from \"./lib/command.js\";\nimport { Readable } from \"stream\";\n\nexport const convexExport = new Command(\"export\")\n  .summary(\"Export data from your deployment to a ZIP file\")\n  .description(\n    \"Export data, and optionally file storage, from your Convex deployment to a ZIP file.\\n\" +\n      \"By default, this exports from your dev deployment.\",\n  )\n  .requiredOption(\n    \"--path <zipFilePath>\",\n    \"Exports data into a ZIP file at this path, which may be a directory or unoccupied .zip path\",\n  )\n  .addOption(\n    new Option(\n      \"--include-file-storage\",\n      \"Includes stored files (https://dashboard.convex.dev/deployment/files) in a _storage folder within the ZIP file\",\n    ),\n  )\n  .addDeploymentSelectionOptions(actionDescription(\"Export data from\"))\n  .showHelpAfterError()\n  .action(async (options) => {\n    const ctx = oneoffContext;\n\n    const deploymentSelection = deploymentSelectionFromOptions(options);\n\n    const {\n      adminKey,\n      url: deploymentUrl,\n      deploymentName,\n    } = await fetchDeploymentCredentialsProvisionProd(ctx, deploymentSelection);\n\n    const inputPath = options.path;\n    const includeStorage = !!options.includeFileStorage;\n\n    await ensureHasConvexDependency(ctx, \"export\");\n\n    const deploymentNotice = options.prod\n      ? ` in your ${chalk.bold(\"prod\")} deployment`\n      : \"\";\n    showSpinner(ctx, `Creating snapshot export${deploymentNotice}`);\n\n    const fetch = deploymentFetch(deploymentUrl, adminKey);\n    try {\n      await fetch(`/api/export/request/zip?includeStorage=${includeStorage}`, {\n        method: \"POST\",\n      });\n    } catch (e) {\n      return await logAndHandleFetchError(ctx, e);\n    }\n\n    const snapshotExportState = await waitForStableExportState(\n      ctx,\n      deploymentUrl,\n      adminKey,\n    );\n    switch (snapshotExportState.state) {\n      case \"completed\":\n        stopSpinner(ctx);\n        logFinishedStep(\n          ctx,\n          `Created snapshot export at timestamp ${snapshotExportState.start_ts}`,\n        );\n        logFinishedStep(\n          ctx,\n          `Export is available at ${await deploymentDashboardUrlPage(\n            deploymentName ?? null,\n            \"/settings/snapshot-export\",\n          )}`,\n        );\n        break;\n      case \"requested\":\n      case \"in_progress\": {\n        logFailure(ctx, `WARNING: Export is continuing to run on the server.`);\n        return await ctx.crash(1);\n      }\n      default: {\n        const _: never = snapshotExportState;\n        logFailure(\n          ctx,\n          `unknown error: unexpected state ${snapshotExportState as any}`,\n        );\n        return await ctx.crash(1);\n      }\n    }\n\n    showSpinner(ctx, `Downloading snapshot export to ${chalk.bold(inputPath)}`);\n    const exportUrl = `/api/export/zip/${snapshotExportState.start_ts.toString()}?adminKey=${encodeURIComponent(\n      adminKey,\n    )}`;\n    let response: Response;\n    try {\n      response = await fetch(exportUrl, {\n        method: \"GET\",\n      });\n    } catch (e) {\n      return await logAndHandleFetchError(ctx, e);\n    }\n\n    let filePath;\n    if (ctx.fs.exists(inputPath)) {\n      const st = ctx.fs.stat(inputPath);\n      if (st.isDirectory()) {\n        const contentDisposition =\n          response.headers.get(\"content-disposition\") ?? \"\";\n        let filename = `snapshot_${snapshotExportState.start_ts.toString()}.zip`;\n        if (contentDisposition.startsWith(\"attachment; filename=\")) {\n          filename = contentDisposition.slice(\"attachment; filename=\".length);\n        }\n        filePath = path.join(inputPath, filename);\n      } else {\n        logFailure(ctx, `Error: Path ${chalk.bold(inputPath)} already exists.`);\n        return await ctx.crash(1, \"invalid filesystem data\");\n      }\n    } else {\n      filePath = inputPath;\n    }\n    changeSpinner(\n      ctx,\n      `Downloading snapshot export to ${chalk.bold(filePath)}`,\n    );\n\n    try {\n      await nodeFs.writeFileStream(\n        filePath,\n        Readable.fromWeb(response.body! as any),\n      );\n    } catch (e) {\n      logFailure(ctx, `Exporting data failed`);\n      logError(ctx, chalk.red(e));\n      return await ctx.crash(1);\n    }\n    stopSpinner(ctx);\n    logFinishedStep(\n      ctx,\n      `Downloaded snapshot export to ${chalk.bold(filePath)}`,\n    );\n  });\n\ntype SnapshotExportState =\n  | { state: \"requested\" }\n  | { state: \"in_progress\" }\n  | {\n      state: \"completed\";\n      complete_ts: bigint;\n      start_ts: bigint;\n      zip_object_key: string;\n    };\n\nasync function waitForStableExportState(\n  ctx: Context,\n  deploymentUrl: string,\n  adminKey: string,\n): Promise<SnapshotExportState> {\n  const [donePromise, onDone] = waitUntilCalled();\n  let snapshotExportState: SnapshotExportState;\n  await subscribe(\n    ctx,\n    deploymentUrl,\n    adminKey,\n    \"_system/cli/exports:getLatest\",\n    {},\n    donePromise,\n    {\n      onChange: (value: any) => {\n        // NOTE: `value` would only be `null` if there has never been an export\n        // requested.\n        snapshotExportState = value;\n        switch (snapshotExportState.state) {\n          case \"requested\":\n          case \"in_progress\":\n            // Not a stable state.\n            break;\n          case \"completed\":\n            onDone();\n            break;\n          default: {\n            const _: never = snapshotExportState;\n            onDone();\n          }\n        }\n      },\n    },\n  );\n  return snapshotExportState!;\n}\n"],
  "mappings": "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",
  "names": []
}
